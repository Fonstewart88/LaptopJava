Базовые концепции языка. Вывод информации

System.out.print("Hello World!"); - вывод на консоль
System.out.print("Hello\n\n\nWorld!"); - вывод на консоль с пропуском строк. 
\n - пропускает строку

Переменные в Джава

byte - предназначен для хранения целых чисел. Диапазон чисел от
 -128 до 127, если число будет большим 127 или меньшим -128 , то выдастся ошибка;
short - предназначен для хранения целых чисел. Диапазон чисел от
 -32768 до 32767;
int - предназначен для хранения целых чисел. Диапазон чисел от
 -2147483648 до 2147483647;
long - предназначен для хранения целых чисел. Диапазон чисел от
 –9 223 372 036 854 775 808 до 9 223 372 036 854 775 807.
 float - для создания чисел с плавающей точкой. Диапазон чисел от от
  -3.4*1038 до 3.4*1038;
 double - для создания чисел с плавающей точкой. Диапазон чисел от
  ±4.9*10-324 до ±1.8*10308.
boolean - логический тип данных. Предназначен для записи истинного 
(true) или ложного (false) значения;
char - тип данных для работы с символами. Позволяет поместить в одинарных
кавычках какой-либо символ;
String - тип данных для текста. В двойных кавычках можно сохранить 
одно или множество слов.

Для создания переменной необходимо указать тип данных и её название.
Также можно сразу же добавить к ней значение:
int a = 0; // Добавление значения сразу
byte c; // Создание переменной без значения
short b, y = 342; // Создание нескольких переменных
Чтобы записать данные в переменную с типом float или double необходимо после числа дописать
букву f или d соответсвенно.

Данные от пользователя.

Scanner some_name = new Scanner(System.in); // Создаем объект с именем some_name
Чтобы получить данные от пользователя мы используем метод класса:
int val = some_name.nextInt();
Если мы хотим получить не число, а строку или число с плавающей точкой, то необходимо
использовать другие методы.
nextLine () - для ввода строки. Возвращаемый тип данных String;
nextInt () - для ввода целых чисел. Возвращаемый тип данных int;
nextFloat () - для ввода чисел с плавающей точкой. Возвращаемый тип данных float;
nextDouble () - для ввода больших чисел с плавающей точкой. Возвращаемый тип double.

Математические операции

Если операция проходит над одной и той же переменной, то можно запись сократить:
z = z + 20;
z += 20; // Эта запись аналогична той, что находиться выше

Если нам необходимо увеличить или уменьшить число на 1, то мы можем прописать ++ 
и -- соответсвенно:
z = 10;
z += 1;
z++; // Аналогично тому, что прописано выше

Условные конструкции (if-else, switch-case)

Конструкция if - else
За счёт if else можно проверить одно или несколько условий и в случае их успешной проверки
будет выполнен один, иначе другой.
int a = 2, b = 10;
if (a == b) { // Если a будет равным b, тогда будет выполнен код
	// Здесь код который будет выполнен
	// Если все одна строка кода, то фигурные скобки {}
	// можно не ставить
} else if (a <= b) { // Если а будет меньшим или равным b
	// Если предыдущее условие не будет выполнено,
	// а здесь условие окажется верным,
	// то будет выполнен этот код
} else {
	// Этот код сработает, если другие условия не будет выполнено
}
Если необходимо проверить несколько условий в одном операторе, то можно воспользоваться 
логическим «и» или же логическим «или»:
if (a != b && a > b) {
	// Код будет выполнен, если и первое, и второе условие
	// окажутся верными
}

if (a < b || a == b) {
	// Код будет выполнен, если или первое, или второе условие
	// окажется верным
}

Конструкция switch case
Конструкция switch case обладает более удобным форматом для проверки множественных условий на 
совпадение значения. В конструкцию записывается переменная, что проверяется, а также 
значения на которые происходит проверка.
int x = 23;
switch (x) { // Проверяем переменную x
	case 1: // Если переменная будет равна 1, то здесь сработает код
		// Может быть множество строк, а не только одна
		System.out.print ("Переменная равна 1");
		break; // Указываем конец для кода для этой проверки
	case 56: // Если переменная будет равна 56, то здесь сработает код
		// Может быть множество строк, а не только одна
		System.out.print ("Переменная равна 56");
		break; // Указываем конец для кода для этой проверки
	
	// По аналогии таких проверок может быть множество
	// Также можно добавить проверку, которая сработает в случае
	// если все остальные проверки не сработают
	default:
		System.out.print ("Что-то другое");
		break; // Можно и не ставить, так как это последние условие
}

Тернарная операция
Это сокращенная форма if else. Записывается следующим образом:
int x = 3, a = 12;
int res = x < a ? (x + a) : (x - a);
System.out.println(res);
Мы проверяем, если "x" будет меньше за "a", то мы в переменную res устанавливаем их сумму, 
иначе - их разницу.

Циклы и операторы в них (For, While, Do while)

Цикл For
В цикле for все условия записываются в одном месте, что очень удобно во многих случаях. 
Стандартная запись такого цикла выглядит следующим образом:
for (int i = 5; i < 25; i += 2) {
    if (i % 3 == 0) {
        continue; // Пропускает цикл если значение верно
        
    }
    if (i >= 19) {
        break;   // Останавливает цикл если значение верно
        
    }
    System.out.println("Element: " + i);
}

Цикл While
Суть цикла while не особо отличается от цикла for. Единственное отличие заключается в 
способе записи цикла. В while необходимо прописать лишь условие, а все остальные параметры 
записываются вне цикла:
int i = 1; // Создание переменной
while (i <= 10) { // Здесь только условие
	System.out.println(i);
	i++; // Увеличение переменной
}

Цикл Do While
Цикл схож с циклом while по форме написания, но при этом работает немного по-другому. 
Цикл do..while будет выполнен один раз сто процентов, а дальше проверит условие и 
если оно верно, то цикл будет выполняться дальше:
int x = 13;
do {
	x--;
	System.out.println(x);
} while (x > 10);

Операторы для работы в циклах
Существует три основных оператора для работы в циклах:

Оператор break - служит для выхода из цикла полностью;
Оператор return - выполняет ту же функцию, что и оператор break, но  для циклов лучше 
использовать break;
Оператор continue - пропускает лишь одну итерацию и не выходит из цикла.

Массивы данных. Одномерные и многомерные массивы

Примеры создания массива:
char[] stroka; // Создание пустого массива
int numbers[]; // Не будет считаться ошибкой

int[] nums = new int[4];
nums[0] = 1; // Добавление элементов в массив из 4 элементов

int[] nums2 = new int[] { 1, 2, 3, 5 }; // Присвоение всех значений сразу

Для массивов существует несколько дополнительных методов, что позволяют проводить 
действия над массивом. Рассмотрим несколько из них: 
length - возвращает количество элементов в массиве. 
К примеру, создадим массив arr и укажем для него 3 элемента. 
При вызове функции будет выдано число 3: arr.length;

Arrays.copyOf - копирует один массив в другой. Пример:
int[] arr = new int[] { 1, 2, 3, 5 };
int[] some_new = Arrays.copyOf(arr, arr.length);

Arrays.sort - сортировка массива. Пример:
int[] numbers = new int[] { 1, 7, 3, 5, 2, 6, 4 };
 
Arrays.sort(numbers);

Arrays.toString(массив) - преобразует объект в его строковое представление, 
чтобы он был пригодным для отображения

Многомерный массив

Для создания двумерных массивов необходимо использовать двойные квадратные скобки после 
типа данных. Выглядит такой массив как матрица, а записывается следующим образом:
int[][] x = { { 0, 34, 2 }, { 3, 4, 5 } };
x[0][1] = 1; // Вместо 34 теперь будет 1

Коллекции в Джава (Collections Framework)

Основные коллекции
Помимо главного интерфейса Collection есть три других главных формата:

List - коллекция для создания массивов данных, где индексами являются числа (0, 1, 2 и так далее);
Set - тоже самое что List, вот только в Set нельзя установить повторяющиеся элементы;
Map - коллекция для создания массивов данных, где индексами являются 
ключи ("one", "2", "three" и так далее).

При создании коллекции необходимо указать тип данных, имя, а также выделение памяти:
ArrayList<Float> numbers = new ArrayList<>(1);
LinkedList<String> names = new LinkedList<>();

add() - добавление элемента в конец массива;
remove() - удаление элемента из массива по его индексу;
clear() - очистка всего массива;
size() - получение размера массива (количество элементов);
addFirst() - добавление элемента в начало массива;
addLast() - добавление элемента в конец;
clone() - выполняет клонирование массива;
get() - возвращает элемент по индексу;
getFirst() - возвращает первый элемент в массиве;
getLast() - возвращает последний элемент в массиве;
set(index, element) - меняет значение элемента по индексу.

Функции в языке Джава

Для создания функций необходимо указать возвращаемый тип данных, указать название и параметры. 
В случае когда функция ничего не возвращает, то указывается тип данных void.
public static void test() {
	System.out.print("Вывод чего-либо в консоль");
}

Если функция должна что-либо вернуть, то прописываем тип данных который будет возвращен. 
Для возвращения данных используем ключевое слово return:
public static double test(double some_number) {
	some_number *= 2;
	return some_number;
}

Класс String

public static void main(String[] args) {
    String command = "Follow" + " " + "the" + " " + "white" + " " + "rabbit";
    System.out.println(command); // Follow the white rabbit
}

строка.toUpperCase - Перевод в верхний регистр
строка.trim - удаление пробелов из строк

Класс StringBuffer

Чтобы справиться с созданием временного мусора из-за модификаций объекта String, 
можно использовать класс StringBuffer. 
StringBuffer sb = new StringBuffer();
StringBuffer sb2 = new StringBuffer("Not empty");

Конкатенация строк через StringBuffer в Java выполняется с помощью метода append. 
Метод append в классе StringBuffer перегружен таким образом, что может принимать в себя 
практически любой тип данных:

public static void main(String[] args) {
    StringBuffer sb = new StringBuffer();

    sb.append(new Integer(2));
    sb.append("; ");
    sb.append(false);
    sb.append("; ");
    sb.append(Arrays.asList(1,2,3));
    sb.append("; ");

    System.out.println(sb); // 2; false; [1, 2, 3];
}
Пример выше можно написать так: 
public static void main(String[] args) {
    StringBuffer sb = new StringBuffer();

    sb.append(new Integer(2))
            .append("; ")
            .append(false)
            .append("; ")
            .append(Arrays.asList(1,2,3))
            .append("; ");

    System.out.println(sb); // 2; false; [1, 2, 3];
}

Для работы со строками у класса StringBuffer есть ряд методов. Перечислим основные:
delete(int start, int end) — удаляет подстроку символов начиная с позиции start, 
заканчивая end
deleteCharAt(int index) — удаляет символ в позиции index
insert(int offset, String str) — вставляет строку str в позицию offset. 
Метод insert также перегружен и может принимать различные аргументы
replace(int start, int end, String str) — заменит все символы начиная с позиции 
start до позиции end на str
reverse() — меняет порядок всех символов на противоположный
substring(int start) — вернет подстроку, начиная с позиции start
substring(int start, int end) — вернет подстроку, начиная с позиции start до позиции end

Как работают указанные выше методы? Посмотрим на практике:

public static void main(String[] args) {
    String numbers = "0123456789";

    StringBuffer sb = new StringBuffer(numbers);

    System.out.println(sb.substring(3)); // 3456789
    System.out.println(sb.substring(4, 8)); // 4567
    System.out.println(sb.replace(3, 5, "ABCDE")); // 012ABCDE56789

    sb = new StringBuffer(numbers);
    System.out.println(sb.reverse()); // 9876543210
    sb.reverse(); // Вернем изначальный порядок

    sb = new StringBuffer(numbers);
    System.out.println(sb.delete(5, 9)); // 012349
    System.out.println(sb.deleteCharAt(1)); // 02349
    System.out.println(sb.insert(1, "One")); // 0One2349
   }


Класс StringBuilder

StringBuilder в Java — класс, представляющий последовательность символов. 
Он очень похож на StringBuffer во всем, кроме потокобезопасности.   
пример:
public static void main(String[] args) {
    String numbers = "0123456789";

    StringBuilder sb = new StringBuilder(numbers);

    System.out.println(sb.substring(3)); //3456789
    System.out.println(sb.substring(4, 8)); //4567
    System.out.println(sb.replace(3, 5, "ABCDE")); //012ABCDE56789

    sb = new StringBuilder(numbers);
    System.out.println(sb.reverse()); //9876543210
    sb.reverse(); // Вернем изначальный порядок

    sb = new StringBuilder(numbers);
    System.out.println(sb.delete(5, 9)); //012349
    System.out.println(sb.deleteCharAt(1)); //02349
    System.out.println(sb.insert(1, "One")); //0One2349